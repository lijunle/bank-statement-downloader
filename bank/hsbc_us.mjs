/**
 * HSBC US Bank API implementation for retrieving bank statements
 * @see analyze/hsbc_us.md
 */

/** @type {string} */
export const bankId = 'hsbc_us';

/** @type {string} */
export const bankName = 'HSBC US';

const BASE_URL = 'https://www.us.hsbc.com';
const API_BASE = '/api';

/**
 * Get the device fingerprint data from the page
 * This is generated by client-side JavaScript and stored in the page
 * @returns {string}
 */
function getJscData() {
    // Try to extract the x-hsbc-jsc-data from the page's JavaScript context
    // This is generated dynamically by HSBC's client-side code
    try {
        // Look for the JSC data in various possible locations
        const scriptElements = document.querySelectorAll('script');
        for (const script of Array.from(scriptElements)) {
            const content = script.textContent || '';
            const match = content.match(/x-hsbc-jsc-data["']?\s*:\s*["']([^"']+)["']/);
            if (match) {
                return match[1];
            }
        }
    } catch (error) {
        console.warn('Failed to extract JSC data from page:', error);
    }

    // Return a placeholder that may be updated by HSBC's client code
    // In practice, this value needs to be present for the API to work
    return '';
}

/**
 * Makes an authenticated API request with all required headers
 * @param {string} endpoint - API endpoint path (starting with /)
 * @param {RequestInit} [options] - Additional fetch options
 * @returns {Promise<Response>}
 */
async function makeAuthenticatedRequest(endpoint, options = {}) {
    const url = `${BASE_URL}${endpoint}`;

    const headers = {
        'accept': 'application/json, text/plain, */*',
        'content-type': 'application/json',
        'token_type': 'SESSION_TOKEN',
        'x-hsbc-channel-id': 'OHI',
        'x-hsbc-chnl-countrycode': 'US',
        'x-hsbc-chnl-group-member': 'HBUS',
        'x-hsbc-client-id': '0472ac925a924d889f35780070fae67c',
        'x-hsbc-global-channel-id': 'WEB',
        'x-hsbc-jsc-data': getJscData(),
        'x-hsbc-locale': 'en_US',
        'x-hsbc-source-system-id': '9847446',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-origin',
        ...options.headers,
    };

    const response = await fetch(url, {
        ...options,
        headers,
        credentials: 'include', // Include cookies (dspSession, dxp-pep-token, etc.)
    });

    if (!response.ok) {
        throw new Error(`HSBC US API request failed: ${response.status} ${response.statusText} at ${endpoint}`);
    }

    return response;
}

/**
 * Get the current session ID from cookies
 * @returns {string}
 */
export function getSessionId() {
    // HSBC uses multiple cookies for session management:
    // - dspSession: Primary session cookie (HttpOnly - not accessible)
    // - dxp-pep-token: JWT token (HttpOnly - not accessible)
    // - HSBC_BROWSER_COOKIE: Browser identification (HttpOnly - not accessible)
    // - scid: Session/client ID (accessible, used in extension context)
    // - cdSNum: Session number (accessible in console, may not be in extension)

    const cookies = document.cookie.split('; ');

    // First try scid (session/client ID) - available in extension context
    const scidCookie = cookies.find(c => c.startsWith('scid='));
    if (scidCookie) {
        const sessionId = scidCookie.split('=')[1];
        if (sessionId) {
            return sessionId;
        }
    }

    // Fallback to cdSNum if available (works in browser console)
    const cdSNumCookie = cookies.find(c => c.startsWith('cdSNum='));
    if (cdSNumCookie) {
        const sessionId = cdSNumCookie.split('=')[1];
        if (sessionId) {
            return sessionId;
        }
    }

    // Check if user is logged in by looking for authentication indicators
    const authTimeCookie = cookies.find(c => c.startsWith('AUTHTIME='));
    if (!authTimeCookie) {
        throw new Error('Not logged in to HSBC US. Please log in first.');
    }

    throw new Error('Session ID not found. Please ensure you are logged in and try again.');
}

/**
 * Get the current user profile
 * @param {string} sessionId - Session ID (not used, kept for interface compatibility)
 * @returns {Promise<import('./bank.types').Profile>}
 */
export async function getProfile(sessionId) {
    try {
        const response = await makeAuthenticatedRequest(
            `${API_BASE}/dcc-us-hbus-global-utilities-papi-prod-proxy/v2/dashboard-data?lastLoginFormat=ISO`
        );

        const data = /** @type {any} */ (await response.json());

        if (!data?.dashboardData?.customerName) {
            throw new Error('Invalid response format from dashboard data API');
        }

        const customerName = data.dashboardData.customerName;
        const fullName = `${customerName.firstName} ${customerName.lastName}`.trim();

        return {
            sessionId,
            profileId: sessionId, // Use session ID as profile ID since HSBC doesn't expose a unique profile identifier
            profileName: fullName || 'HSBC US Customer',
        };
    } catch (error) {
        const err = /** @type {Error} */ (error);
        throw new Error(`Failed to get profile: ${err.message}`);
    }
}

/**
 * Map HSBC product category code to account type
 * @param {string} categoryCode - The normalized product category code
 * @returns {import('./bank.types').AccountType}
 */
function mapAccountType(categoryCode) {
    switch (categoryCode) {
        case 'CHQ': // Checking
        case 'DDA': // Demand Deposit Account
            return 'Checking';
        case 'SAV': // Savings
        case 'SDA': // Savings Deposit Account
            return 'Savings';
        case 'CCA': // Credit Card
        case 'CC':
            return 'CreditCard';
        case 'LON': // Loan
        case 'MTG': // Mortgage
            return 'Loan';
        case 'INV': // Investment
            return 'Investment';
        default:
            // Default to Savings for unknown types
            return 'Savings';
    }
}

/**
 * Retrieves all accounts for the logged-in user
 * @param {import('./bank.types').Profile} profile - The user profile
 * @returns {Promise<import('./bank.types').Account[]>}
 */
export async function getAccounts(profile) {
    try {
        const response = await makeAuthenticatedRequest(
            `${API_BASE}/dcc-us-hbus-account-list-papi-prod-proxy/v3/accounts/domestic?eligibilityType=estatements`
        );

        const data = /** @type {any} */ (await response.json());

        if (!data?.accountList || !Array.isArray(data.accountList)) {
            throw new Error('Invalid response format from account list API');
        }

        const accounts = [];

        for (const acct of data.accountList) {
            if (acct.accountStatus !== 'ACTIVE') {
                continue; // Skip inactive accounts
            }

            // Store the accountIdentifierIndex in accountId for use in getStatements
            const accountId = acct.accountIdentifier?.accountIdentifierIndex;
            if (!accountId) {
                console.warn('Account missing accountIdentifierIndex:', acct);
                continue;
            }

            accounts.push({
                profile,
                accountId,
                accountName: acct.productDescription || `Account ${acct.accountDisplay}`,
                accountMask: acct.accountDisplay?.slice(-4) || '****',
                accountType: mapAccountType(acct.accountIdentifier?.normalisedProductCategoryCode || ''),
            });
        }

        return accounts;
    } catch (error) {
        const err = /** @type {Error} */ (error);
        throw new Error(`Failed to get accounts: ${err.message}`);
    }
}

/**
 * Retrieves all statements for a specific account
 * @param {import('./bank.types').Account} account - The account to get statements for
 * @returns {Promise<import('./bank.types').Statement[]>}
 */
export async function getStatements(account) {
    try {
        // The accountId contains the accountIdentifierIndex from getAccounts
        const accountIdentifierIndex = account.accountId;

        const response = await makeAuthenticatedRequest(
            `${API_BASE}/mmf-files-statements--us-hbus-prod-proxy/v1/customer-accounts/${encodeURIComponent(accountIdentifierIndex)}/statements?documentType=BOTH`
        );

        const data = /** @type {any} */ (await response.json());

        if (!data?.statements || !Array.isArray(data.statements)) {
            throw new Error('Invalid response format from statement list API');
        }

        const statements = [];

        for (const stmt of data.statements) {
            if (!stmt.statementIdentifier || !stmt.statementDate) {
                console.warn('Statement missing required fields:', stmt);
                continue;
            }

            statements.push({
                account,
                // Store the statementIdentifier in statementId for use in downloadStatement
                statementId: stmt.statementIdentifier,
                // Convert date to ISO format (YYYY-MM-DD is already in the correct format)
                statementDate: stmt.statementDate,
            });
        }

        return statements;
    } catch (error) {
        const err = /** @type {Error} */ (error);
        throw new Error(`Failed to get statements for account ${account.accountMask}: ${err.message}`);
    }
}

/**
 * Downloads a statement PDF
 * @param {import('./bank.types').Statement} statement - The statement to download
 * @returns {Promise<Blob>}
 */
export async function downloadStatement(statement) {
    try {
        // The statementId contains the statementIdentifier from getStatements
        const statementIdentifier = statement.statementId;

        const response = await makeAuthenticatedRequest(
            `${API_BASE}/mmf-files-statements--us-hbus-prod-proxy/v1/statements/${encodeURIComponent(statementIdentifier)}/statement-files`
        );

        // Check content type to ensure we got a PDF
        const contentType = response.headers.get('content-type');
        if (contentType && !contentType.includes('application/pdf')) {
            throw new Error(`Expected PDF but got ${contentType}`);
        }

        const blob = await response.blob();

        if (blob.size === 0) {
            throw new Error('Downloaded statement file is empty');
        }

        return blob;
    } catch (error) {
        const err = /** @type {Error} */ (error);
        throw new Error(`Failed to download statement for ${statement.statementDate}: ${err.message}`);
    }
}
